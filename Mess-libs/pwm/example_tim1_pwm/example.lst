
example.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
	void InterruptVector()         __attribute__((naked)) __attribute((section(".init"))) __attribute((weak,alias("InterruptVectorDefault"))) __attribute((naked));
	void InterruptVectorDefault()  __attribute__((naked)) __attribute((section(".init"))) __attribute((naked));
	void InterruptVectorDefault( void )
	{
		#if !defined(FUNCONF_TINYVECTOR) || !FUNCONF_TINYVECTOR
			asm volatile( DEFAULT_INTERRUPT_VECTOR_CONTENTS );
   0:	2c60006f          	j	2c6 <handle_reset>
   4:	0000                	unimp
   6:	0000                	unimp
   8:	0382                	c.slli64	t2
   a:	0000                	unimp
   c:	0332                	slli	t1,t1,0xc
	...
  2e:	0000                	unimp
  30:	05d6                	slli	a1,a1,0x15
  32:	0000                	unimp
  34:	0000                	unimp
  36:	0000                	unimp
  38:	0332                	slli	t1,t1,0xc
  3a:	0000                	unimp
  3c:	0000                	unimp
  3e:	0000                	unimp
  40:	0332                	slli	t1,t1,0xc
  42:	0000                	unimp
  44:	0332                	slli	t1,t1,0xc
  46:	0000                	unimp
  48:	0332                	slli	t1,t1,0xc
  4a:	0000                	unimp
  4c:	0332                	slli	t1,t1,0xc
  4e:	0000                	unimp
  50:	0332                	slli	t1,t1,0xc
  52:	0000                	unimp
  54:	0332                	slli	t1,t1,0xc
  56:	0000                	unimp
  58:	0332                	slli	t1,t1,0xc
  5a:	0000                	unimp
  5c:	0332                	slli	t1,t1,0xc
  5e:	0000                	unimp
  60:	0332                	slli	t1,t1,0xc
  62:	0000                	unimp
  64:	0332                	slli	t1,t1,0xc
  66:	0000                	unimp
  68:	0332                	slli	t1,t1,0xc
  6a:	0000                	unimp
  6c:	0332                	slli	t1,t1,0xc
  6e:	0000                	unimp
  70:	0332                	slli	t1,t1,0xc
  72:	0000                	unimp
  74:	0332                	slli	t1,t1,0xc
  76:	0000                	unimp
  78:	0332                	slli	t1,t1,0xc
  7a:	0000                	unimp
  7c:	0332                	slli	t1,t1,0xc
  7e:	0000                	unimp
  80:	0332                	slli	t1,t1,0xc
  82:	0000                	unimp
  84:	0332                	slli	t1,t1,0xc
  86:	0000                	unimp
  88:	0332                	slli	t1,t1,0xc
  8a:	0000                	unimp
  8c:	0332                	slli	t1,t1,0xc
  8e:	0000                	unimp
  90:	0332                	slli	t1,t1,0xc
  92:	0000                	unimp
  94:	0332                	slli	t1,t1,0xc
  96:	0000                	unimp
  98:	0332                	slli	t1,t1,0xc
  9a:	0000                	unimp
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <PrintHex>:
	while( (*DMDATA0) & 0x80 );
  a0:	e0000737          	lui	a4,0xe0000
  a4:	0f472783          	lw	a5,244(a4) # e00000f4 <_eusrstack+0xbffff8f4>
  a8:	0f470693          	addi	a3,a4,244
  ac:	0807f793          	andi	a5,a5,128
  b0:	fbf5                	bnez	a5,a4 <PrintHex+0x4>
	*DMDATA0 = 0x78302088; //" 0x"
  b2:	783027b7          	lui	a5,0x78302
  b6:	08878793          	addi	a5,a5,136 # 78302088 <_eusrstack+0x58301888>
  ba:	c29c                	sw	a5,0(a3)
	for( shift = 28; shift >= 0; shift -= 4 )
  bc:	4771                	li	a4,28
		while( (*DMDATA0) & 0x80 );
  be:	e0000637          	lui	a2,0xe0000
		s += ( s < 10 ) ? '0' : ('a' - 10);
  c2:	4325                	li	t1,9
	for( shift = 28; shift >= 0; shift -= 4 )
  c4:	55f1                	li	a1,-4
		while( (*DMDATA0) & 0x80 );
  c6:	0f462783          	lw	a5,244(a2) # e00000f4 <_eusrstack+0xbffff8f4>
  ca:	0807f793          	andi	a5,a5,128
  ce:	ffe5                	bnez	a5,c6 <PrintHex+0x26>
		int s = (n>>shift) & 0xf;
  d0:	00e557b3          	srl	a5,a0,a4
  d4:	00f7f693          	andi	a3,a5,15
		s += ( s < 10 ) ? '0' : ('a' - 10);
  d8:	03000793          	li	a5,48
  dc:	00d35463          	bge	t1,a3,e4 <PrintHex+0x44>
  e0:	05700793          	li	a5,87
  e4:	97b6                	add	a5,a5,a3
		*DMDATA0 = 0x85 | (s<<8); //" 0x"
  e6:	07a2                	slli	a5,a5,0x8
  e8:	0857e793          	ori	a5,a5,133
  ec:	0ef62a23          	sw	a5,244(a2)
	for( shift = 28; shift >= 0; shift -= 4 )
  f0:	1771                	addi	a4,a4,-4
  f2:	fcb71ae3          	bne	a4,a1,c6 <PrintHex+0x26>
}
  f6:	8082                	ret

000000f8 <fun_timPWM_reload>:
}

void fun_timPWM_reload(TIM_PWM_t* model) {
	model->counter = 0;
	model->timeRef = 0;
	funPinMode(model->pin, GPIO_Speed_10MHz | GPIO_CNF_OUT_PP_AF);
  f8:	00054703          	lbu	a4,0(a0)
  fc:	400117b7          	lui	a5,0x40011
 100:	80078793          	addi	a5,a5,-2048 # 40010800 <_eusrstack+0x20010000>
 104:	00475693          	srli	a3,a4,0x4
 108:	06aa                	slli	a3,a3,0xa
 10a:	96be                	add	a3,a3,a5
 10c:	8b3d                	andi	a4,a4,15
 10e:	4290                	lw	a2,0(a3)
 110:	070a                	slli	a4,a4,0x2
 112:	47bd                	li	a5,15
 114:	00e797b3          	sll	a5,a5,a4
 118:	fff7c793          	not	a5,a5
 11c:	8ff1                	and	a5,a5,a2
 11e:	4625                	li	a2,9
 120:	00e61733          	sll	a4,a2,a4
	model->counter = 0;
 124:	00052423          	sw	zero,8(a0)
	model->timeRef = 0;
 128:	00052623          	sw	zero,12(a0)
	funPinMode(model->pin, GPIO_Speed_10MHz | GPIO_CNF_OUT_PP_AF);
 12c:	8fd9                	or	a5,a5,a4
 12e:	c29c                	sw	a5,0(a3)
	TIM_TypeDef* timer = model->TIM;
 130:	415c                	lw	a5,4(a0)

	// default value
	timer->CH1CVR = 255;
 132:	0ff00713          	li	a4,255
	timer->CH2CVR = 255;
	timer->CH3CVR = 255;
	timer->CH4CVR = 255;

	switch (model->CCER) {
 136:	04000693          	li	a3,64
	timer->CH1CVR = 255;
 13a:	dbd8                	sw	a4,52(a5)
	timer->CH2CVR = 255;
 13c:	df98                	sw	a4,56(a5)
	timer->CH3CVR = 255;
 13e:	dfd8                	sw	a4,60(a5)
	timer->CH4CVR = 255;
 140:	c3b8                	sw	a4,64(a5)
	switch (model->CCER) {
 142:	00255703          	lhu	a4,2(a0)
 146:	0ad70363          	beq	a4,a3,1ec <fun_timPWM_reload+0xf4>
 14a:	00e6ec63          	bltu	a3,a4,162 <fun_timPWM_reload+0x6a>
 14e:	4691                	li	a3,4
 150:	04d70463          	beq	a4,a3,198 <fun_timPWM_reload+0xa0>
 154:	46c1                	li	a3,16
 156:	06d70563          	beq	a4,a3,1c0 <fun_timPWM_reload+0xc8>
 15a:	4685                	li	a3,1
 15c:	00d70b63          	beq	a4,a3,172 <fun_timPWM_reload+0x7a>
 160:	8082                	ret
 162:	10000693          	li	a3,256
 166:	0ad70263          	beq	a4,a3,20a <fun_timPWM_reload+0x112>
 16a:	6685                	lui	a3,0x1
 16c:	0cd70163          	beq	a4,a3,22e <fun_timPWM_reload+0x136>
 170:	8082                	ret
		//# TIM1->CHCTLR1 Control Reg1: CH1 & CH2
		case TIM_CC1E:
			timer->CHCTLR1 |= TIM_OC1M_2 | TIM_OC1M_1 | TIM_OC1PE;		// TIM_OC1PE is used by TIM2 only
 172:	0187d683          	lhu	a3,24(a5)
 176:	06c2                	slli	a3,a3,0x10
 178:	82c1                	srli	a3,a3,0x10
 17a:	0686e693          	ori	a3,a3,104
 17e:	00d79c23          	sh	a3,24(a5)
			timer->CCER |= TIM_CC1E | TIM_CC1P;
 182:	0207d683          	lhu	a3,32(a5)
 186:	06c2                	slli	a3,a3,0x10
 188:	82c1                	srli	a3,a3,0x10
 18a:	0036e693          	ori	a3,a3,3
 18e:	02d79023          	sh	a3,32(a5)
			model->channel = 1;
 192:	00e500a3          	sb	a4,1(a0)
			break;
 196:	8082                	ret
		case TIM_CC1NE:
			timer->CHCTLR1 |= TIM_OC1M_2 | TIM_OC1M_1;
 198:	0187d703          	lhu	a4,24(a5)
 19c:	0742                	slli	a4,a4,0x10
 19e:	8341                	srli	a4,a4,0x10
 1a0:	06076713          	ori	a4,a4,96
 1a4:	00e79c23          	sh	a4,24(a5)
			timer->CCER |= TIM_CC1NE | TIM_CC1NP;
 1a8:	0207d703          	lhu	a4,32(a5)
 1ac:	0742                	slli	a4,a4,0x10
 1ae:	8341                	srli	a4,a4,0x10
 1b0:	00c76713          	ori	a4,a4,12
 1b4:	02e79023          	sh	a4,32(a5)
			model->channel = 1;
 1b8:	4785                	li	a5,1
			break;
		// case TIM_CC3NE: TIM1->CCER |= TIM_CC3E | TIM_CC3NP; break;	//! Prevent overwrite SWDIO
		case TIM_CC4E:
			timer->CHCTLR2 |= TIM_OC4M_2 | TIM_OC4M_1 | TIM_OC4PE;		// TIM_OC4PE is used by TIM2 only
			timer->CCER |= TIM_CC4E | TIM_CC4P;
			model->channel = 4;
 1ba:	00f500a3          	sb	a5,1(a0)
			break;
	}
}
 1be:	8082                	ret
			timer->CHCTLR1 |= TIM_OC2M_2 | TIM_OC2M_1 | TIM_OC2PE;		// TIM_OC2PE is used by TIM2 only
 1c0:	0187d703          	lhu	a4,24(a5)
 1c4:	669d                	lui	a3,0x7
 1c6:	80068693          	addi	a3,a3,-2048 # 6800 <example.c.5e9830c8+0x447c>
 1ca:	0742                	slli	a4,a4,0x10
 1cc:	8341                	srli	a4,a4,0x10
 1ce:	8f55                	or	a4,a4,a3
 1d0:	0742                	slli	a4,a4,0x10
 1d2:	8341                	srli	a4,a4,0x10
 1d4:	00e79c23          	sh	a4,24(a5)
			timer->CCER |= TIM_CC2E | TIM_CC2P;
 1d8:	0207d703          	lhu	a4,32(a5)
 1dc:	0742                	slli	a4,a4,0x10
 1de:	8341                	srli	a4,a4,0x10
 1e0:	03076713          	ori	a4,a4,48
			timer->CCER |= TIM_CC2NE | TIM_CC2NP;
 1e4:	02e79023          	sh	a4,32(a5)
			model->channel = 2;
 1e8:	4789                	li	a5,2
 1ea:	bfc1                	j	1ba <fun_timPWM_reload+0xc2>
			timer->CHCTLR1 |= TIM_OC2M_2 | TIM_OC2M_1;
 1ec:	0187d703          	lhu	a4,24(a5)
 1f0:	6699                	lui	a3,0x6
 1f2:	0742                	slli	a4,a4,0x10
 1f4:	8341                	srli	a4,a4,0x10
 1f6:	8f55                	or	a4,a4,a3
 1f8:	00e79c23          	sh	a4,24(a5)
			timer->CCER |= TIM_CC2NE | TIM_CC2NP;
 1fc:	0207d703          	lhu	a4,32(a5)
 200:	0742                	slli	a4,a4,0x10
 202:	8341                	srli	a4,a4,0x10
 204:	0c076713          	ori	a4,a4,192
 208:	bff1                	j	1e4 <fun_timPWM_reload+0xec>
			timer->CHCTLR2 |= TIM_OC3M_2 | TIM_OC3M_1 | TIM_OC3PE;		// TIM_OC3PE is used by TIM2 only
 20a:	01c7d703          	lhu	a4,28(a5)
 20e:	0742                	slli	a4,a4,0x10
 210:	8341                	srli	a4,a4,0x10
 212:	06876713          	ori	a4,a4,104
 216:	00e79e23          	sh	a4,28(a5)
			timer->CCER |= TIM_CC3E | TIM_CC3P;
 21a:	0207d703          	lhu	a4,32(a5)
 21e:	0742                	slli	a4,a4,0x10
 220:	8341                	srli	a4,a4,0x10
 222:	30076713          	ori	a4,a4,768
 226:	02e79023          	sh	a4,32(a5)
			model->channel = 3;
 22a:	478d                	li	a5,3
 22c:	b779                	j	1ba <fun_timPWM_reload+0xc2>
			timer->CHCTLR2 |= TIM_OC4M_2 | TIM_OC4M_1 | TIM_OC4PE;		// TIM_OC4PE is used by TIM2 only
 22e:	01c7d703          	lhu	a4,28(a5)
 232:	669d                	lui	a3,0x7
 234:	80068693          	addi	a3,a3,-2048 # 6800 <example.c.5e9830c8+0x447c>
 238:	0742                	slli	a4,a4,0x10
 23a:	8341                	srli	a4,a4,0x10
 23c:	8f55                	or	a4,a4,a3
 23e:	0742                	slli	a4,a4,0x10
 240:	8341                	srli	a4,a4,0x10
 242:	00e79e23          	sh	a4,28(a5)
			timer->CCER |= TIM_CC4E | TIM_CC4P;
 246:	0207d703          	lhu	a4,32(a5)
 24a:	668d                	lui	a3,0x3
 24c:	0742                	slli	a4,a4,0x10
 24e:	8341                	srli	a4,a4,0x10
 250:	8f55                	or	a4,a4,a3
 252:	02e79023          	sh	a4,32(a5)
			model->channel = 4;
 256:	4791                	li	a5,4
 258:	b78d                	j	1ba <fun_timPWM_reload+0xc2>

0000025a <fun_timPWM_task>:
	}
}


void fun_timPWM_task(uint32_t time, TIM_PWM_t* model) {
	if (time - model->timeRef < 5) { return; }
 25a:	45dc                	lw	a5,12(a1)
 25c:	4611                	li	a2,4
 25e:	40f507b3          	sub	a5,a0,a5
 262:	02f67663          	bgeu	a2,a5,28e <fun_timPWM_task+0x34>
	switch(model->channel) {
 266:	0015c703          	lbu	a4,1(a1)
	model->timeRef = time;
 26a:	c5c8                	sw	a0,12(a1)
	switch(model->channel) {
 26c:	450d                	li	a0,3

	fun_timPWM_setpw(model, model->counter);
 26e:	459c                	lw	a5,8(a1)
	TIM_TypeDef* timer = model->TIM;
 270:	41d4                	lw	a3,4(a1)
	switch(model->channel) {
 272:	04a70063          	beq	a4,a0,2b2 <fun_timPWM_task+0x58>
 276:	00e56d63          	bltu	a0,a4,290 <fun_timPWM_task+0x36>
 27a:	4605                	li	a2,1
 27c:	02c70163          	beq	a4,a2,29e <fun_timPWM_task+0x44>
 280:	4609                	li	a2,2
 282:	02c70363          	beq	a4,a2,2a8 <fun_timPWM_task+0x4e>
	model->counter++;
 286:	0785                	addi	a5,a5,1
	model->counter &= 255;
 288:	0ff7f793          	andi	a5,a5,255
 28c:	c59c                	sw	a5,8(a1)
 28e:	8082                	ret
	switch(model->channel) {
 290:	fec71be3          	bne	a4,a2,286 <fun_timPWM_task+0x2c>
		case 4: timer->CH4CVR = width; break;
 294:	01079713          	slli	a4,a5,0x10
 298:	8341                	srli	a4,a4,0x10
 29a:	c2b8                	sw	a4,64(a3)
 29c:	b7ed                	j	286 <fun_timPWM_task+0x2c>
		case 1: timer->CH1CVR = width; break;
 29e:	01079713          	slli	a4,a5,0x10
 2a2:	8341                	srli	a4,a4,0x10
 2a4:	dad8                	sw	a4,52(a3)
 2a6:	b7c5                	j	286 <fun_timPWM_task+0x2c>
		case 2: timer->CH2CVR = width; break;
 2a8:	01079713          	slli	a4,a5,0x10
 2ac:	8341                	srli	a4,a4,0x10
 2ae:	de98                	sw	a4,56(a3)
 2b0:	bfd9                	j	286 <fun_timPWM_task+0x2c>
		case 3: timer->CH3CVR = width; break;
 2b2:	01079713          	slli	a4,a5,0x10
 2b6:	8341                	srli	a4,a4,0x10
 2b8:	ded8                	sw	a4,60(a3)
 2ba:	b7f1                	j	286 <fun_timPWM_task+0x2c>

000002bc <internal_handle_input.constprop.0>:
void handle_debug_input( int numbytes, uint8_t * data ) __attribute__((weak));
void handle_debug_input( int numbytes, uint8_t * data ) { (void)numbytes; (void)data; }

static void internal_handle_input( volatile uint32_t * dmdata0 )
{
	uint32_t dmd0 = *dmdata0;
 2bc:	e00007b7          	lui	a5,0xe0000
 2c0:	0f47a783          	lw	a5,244(a5) # e00000f4 <_eusrstack+0xbffff8f4>
	int bytes = (dmd0 & 0x3f) - 4;
	if( bytes > 0 && bytes < 16 )
	{
		handle_debug_input( bytes, ((uint8_t*)dmdata0) + 1 );
	}
}
 2c4:	8082                	ret

000002c6 <handle_reset>:
	asm volatile( "\n\
 2c6:	20000197          	auipc	gp,0x20000
 2ca:	13618193          	addi	gp,gp,310 # 200003fc <__global_pointer$>
 2ce:	40418113          	addi	sp,gp,1028 # 20000800 <_eusrstack>
 2d2:	6509                	lui	a0,0x2
 2d4:	88050513          	addi	a0,a0,-1920 # 1880 <ch32fun.c.dbd354d0+0x684>
 2d8:	30051073          	csrw	mstatus,a0
 2dc:	468d                	li	a3,3
 2de:	00000517          	auipc	a0,0x0
 2e2:	d2250513          	addi	a0,a0,-734 # 0 <InterruptVector>
 2e6:	8d55                	or	a0,a0,a3
 2e8:	30551073          	csrw	mtvec,a0
asm volatile(
 2ec:	c0418513          	addi	a0,gp,-1020 # 20000000 <systick_millis>
 2f0:	c0818593          	addi	a1,gp,-1016 # 20000004 <_ebss>
 2f4:	4601                	li	a2,0
 2f6:	00b55663          	bge	a0,a1,302 <handle_reset+0x3c>
 2fa:	c110                	sw	a2,0(a0)
 2fc:	0511                	addi	a0,a0,4
 2fe:	feb54ee3          	blt	a0,a1,2fa <handle_reset+0x34>
 302:	60800513          	li	a0,1544
 306:	c0418593          	addi	a1,gp,-1020 # 20000000 <systick_millis>
 30a:	c0418613          	addi	a2,gp,-1020 # 20000000 <systick_millis>
 30e:	00c58863          	beq	a1,a2,31e <handle_reset+0x58>
 312:	4114                	lw	a3,0(a0)
 314:	c194                	sw	a3,0(a1)
 316:	0511                	addi	a0,a0,4
 318:	0591                	addi	a1,a1,4
 31a:	fec59ae3          	bne	a1,a2,30e <handle_reset+0x48>
	SysTick->CTLR = 5;
 31e:	e000f7b7          	lui	a5,0xe000f
 322:	4715                	li	a4,5
 324:	c398                	sw	a4,0(a5)
asm volatile(
 326:	45400793          	li	a5,1108
 32a:	34179073          	csrw	mepc,a5
 32e:	30200073          	mret

00000332 <ADC1_2_IRQHandler>:

// Return the Machine Exception Program Register (MEPC)
static inline uint32_t __get_MEPC(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mepc" : "=r"(result));
 332:	34102573          	csrr	a0,mepc
	PrintHex( __get_MEPC() ); // "addr2line -e debugprintfdemo.elf 0x000007e6" ---> debugprintfdemo.c:45
 336:	33ad                	jal	a0 <PrintHex>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0, mstatus": "=r"(result) );
 338:	30002573          	csrr	a0,mstatus
	PrintHex( __get_MSTATUS() );
 33c:	3395                	jal	a0 <PrintHex>

// Return the Machine Trap Value Register (MTVAL)
static inline uint32_t __get_MTVAL(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mtval" : "=r" (result) );
 33e:	34302573          	csrr	a0,mtval
	PrintHex( __get_MTVAL() );
 342:	3bb9                	jal	a0 <PrintHex>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mcause": "=r"(result));
 344:	34202573          	csrr	a0,mcause
	PrintHex( __get_MCAUSE() );
 348:	3ba1                	jal	a0 <PrintHex>
	while( (*DMDATA0) & 0x80 );
 34a:	e0000737          	lui	a4,0xe0000
 34e:	0f472783          	lw	a5,244(a4) # e00000f4 <_eusrstack+0xbffff8f4>
 352:	0f470693          	addi	a3,a4,244
 356:	0807f793          	andi	a5,a5,128
 35a:	fbf5                	bnez	a5,34e <ADC1_2_IRQHandler+0x1c>
	*DMDATA0 = 0x0a85;
 35c:	6785                	lui	a5,0x1
 35e:	a8578793          	addi	a5,a5,-1403 # a85 <_data_lma+0x47d>
 362:	c29c                	sw	a5,0(a3)
	while( (*DMDATA0) & 0x80 );
 364:	e0000737          	lui	a4,0xe0000
 368:	0f472783          	lw	a5,244(a4) # e00000f4 <_eusrstack+0xbffff8f4>
 36c:	0f470693          	addi	a3,a4,244
 370:	0807f793          	andi	a5,a5,128
 374:	fbf5                	bnez	a5,368 <ADC1_2_IRQHandler+0x36>
	*DMDATA0 = 0xaaaaaa83;
 376:	aaaab7b7          	lui	a5,0xaaaab
 37a:	a8378793          	addi	a5,a5,-1405 # aaaaaa83 <_eusrstack+0x8aaaa283>
 37e:	c29c                	sw	a5,0(a3)
	asm volatile( "1: j 1b" );
 380:	a001                	j	380 <ADC1_2_IRQHandler+0x4e>

00000382 <NMI_Handler>:
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 382:	40021737          	lui	a4,0x40021
 386:	471c                	lw	a5,8(a4)
 388:	008006b7          	lui	a3,0x800
 38c:	8fd5                	or	a5,a5,a3
 38e:	c71c                	sw	a5,8(a4)

00000390 <putchar>:
}

// single to debug intf
WEAK int putchar(int c)
{
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 390:	e00007b7          	lui	a5,0xe0000
 394:	0f47a783          	lw	a5,244(a5) # e00000f4 <_eusrstack+0xbffff8f4>
 398:	0c000713          	li	a4,192
 39c:	0c07f793          	andi	a5,a5,192
 3a0:	04e78c63          	beq	a5,a4,3f8 <putchar+0x68>
{
 3a4:	1151                	addi	sp,sp,-12
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 3a6:	001007b7          	lui	a5,0x100
{
 3aa:	c222                	sw	s0,4(sp)
 3ac:	c406                	sw	ra,8(sp)
 3ae:	842a                	mv	s0,a0
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 3b0:	0785                	addi	a5,a5,1

	int timeout = FUNCONF_DEBUGPRINTF_TIMEOUT;
	uint32_t lastdmd = 0;

	while( ( lastdmd = (*DMDATA0) ) & 0x80 )
 3b2:	e00006b7          	lui	a3,0xe0000
 3b6:	0f46a703          	lw	a4,244(a3) # e00000f4 <_eusrstack+0xbffff8f4>
 3ba:	0f468613          	addi	a2,a3,244
 3be:	08077593          	andi	a1,a4,128
 3c2:	e185                	bnez	a1,3e2 <putchar+0x52>
			return 0;
		}
	}

	// Simply seeking input.
	if( lastdmd ) internal_handle_input( (uint32_t*)DMDATA0 );
 3c4:	c311                	beqz	a4,3c8 <putchar+0x38>
 3c6:	3ddd                	jal	2bc <internal_handle_input.constprop.0>

	// Write out character.
	*DMDATA0 = 0x85 | ((const char)c<<8);
 3c8:	6541                	lui	a0,0x10
 3ca:	157d                	addi	a0,a0,-1
 3cc:	00841793          	slli	a5,s0,0x8
 3d0:	8fe9                	and	a5,a5,a0
 3d2:	0857e793          	ori	a5,a5,133
 3d6:	e0000737          	lui	a4,0xe0000
 3da:	0ef72a23          	sw	a5,244(a4) # e00000f4 <_eusrstack+0xbffff8f4>
	return 1;
 3de:	4505                	li	a0,1
 3e0:	a801                	j	3f0 <putchar+0x60>
		if( timeout-- == 0 )
 3e2:	17fd                	addi	a5,a5,-1
 3e4:	fbe9                	bnez	a5,3b6 <putchar+0x26>
			*DMDATA0 |= 0xc0;
 3e6:	421c                	lw	a5,0(a2)
 3e8:	4501                	li	a0,0
 3ea:	0c07e793          	ori	a5,a5,192
 3ee:	c21c                	sw	a5,0(a2)
}
 3f0:	40a2                	lw	ra,8(sp)
 3f2:	4412                	lw	s0,4(sp)
 3f4:	0131                	addi	sp,sp,12
 3f6:	8082                	ret
	if( ( *DMDATA0 & 0xc0 ) == 0xc0 ) return 0;
 3f8:	4501                	li	a0,0
}
 3fa:	8082                	ret

000003fc <SystemInit>:
	#endif
#elif defined(CH32X03x)
	FLASH->ACTLR = FLASH_ACTLR_LATENCY_2;                   // +2 Cycle Latency (Recommended per TRM)
#elif defined(CH32V003)
	#if FUNCONF_SYSTEM_CORE_CLOCK > 25000000
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;               // +1 Cycle Latency
 3fc:	400227b7          	lui	a5,0x40022
 400:	4705                	li	a4,1
 402:	c398                	sw	a4,0(a5)
#elif defined(FUNCONF_USE_HSI) && FUNCONF_USE_HSI
	#if defined(CH32V30x) || defined(CH32V20x) || defined(CH32V10x)
		EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;
	#endif
	#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL
		RCC->CFGR0 = BASE_CFGR0;
 404:	400217b7          	lui	a5,0x40021
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 408:	01080737          	lui	a4,0x1080
		RCC->CFGR0 = BASE_CFGR0;
 40c:	0007a223          	sw	zero,4(a5) # 40021004 <_eusrstack+0x20020804>
		RCC->CTLR  = BASE_CTLR | RCC_HSION | RCC_PLLON; 			// Use HSI, enable PLL.
 410:	08170713          	addi	a4,a4,129 # 1080081 <example.c.5e9830c8+0x107dcfd>
 414:	c398                	sw	a4,0(a5)
		FLASH->ACTLR = FLASH_ACTLR_LATENCY_1;       		// +1 Cycle Latency
	#endif
#endif

#if !defined(CH57x) && !defined(CH58x) && !defined(CH59x)
	RCC->INTR  = 0x009F0000;                               // Clear PLL, CSSC, HSE, HSI and LSI ready flags.
 416:	009f0737          	lui	a4,0x9f0
 41a:	c798                	sw	a4,8(a5)
#endif

#if defined(FUNCONF_USE_PLL) && FUNCONF_USE_PLL && !defined(CH57x) && !defined(CH58x) && !defined(CH59x)
	while((RCC->CTLR & RCC_PLLRDY) == 0);                       	// Wait till PLL is ready
 41c:	020006b7          	lui	a3,0x2000
 420:	40021737          	lui	a4,0x40021
 424:	431c                	lw	a5,0(a4)
 426:	8ff5                	and	a5,a5,a3
 428:	dff5                	beqz	a5,424 <SystemInit+0x28>
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 42a:	435c                	lw	a5,4(a4)
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 42c:	400216b7          	lui	a3,0x40021
	uint32_t tmp32 = RCC->CFGR0 & ~(0x03);							// clr the SW
 430:	9bf1                	andi	a5,a5,-4
	RCC->CFGR0 = tmp32 | RCC_SW_PLL;                       			// Select PLL as system clock source
 432:	0027e793          	ori	a5,a5,2
 436:	c35c                	sw	a5,4(a4)
	while ((RCC->CFGR0 & (uint32_t)RCC_SWS) != (uint32_t)0x08); 	// Wait till PLL is used as system clock source
 438:	4721                	li	a4,8
 43a:	42dc                	lw	a5,4(a3)
 43c:	8bb1                	andi	a5,a5,12
 43e:	fee79ee3          	bne	a5,a4,43a <SystemInit+0x3e>
	*DMDATA1 = 0x00;
 442:	e00007b7          	lui	a5,0xe0000
 446:	0e07ac23          	sw	zero,248(a5) # e00000f8 <_eusrstack+0xbffff8f8>
	*DMDATA0 = 0x80;
 44a:	08000713          	li	a4,128
 44e:	0ee7aa23          	sw	a4,244(a5)
	SetupUART( UART_BRR );
#endif
#if defined( FUNCONF_USE_DEBUGPRINTF ) && FUNCONF_USE_DEBUGPRINTF
	SetupDebugPrintf();
#endif
}
 452:	8082                	ret

00000454 <main>:
#include <stdio.h>

#include "../fun_timPWM.h"
#include "../../modules/systick_irq.h"

int main() {
 454:	7159                	addi	sp,sp,-112
 456:	d4a2                	sw	s0,104(sp)
 458:	d686                	sw	ra,108(sp)
 45a:	d2a6                	sw	s1,100(sp)
    SystemInit();
 45c:	3745                	jal	3fc <SystemInit>
* its clock source
*/
void systick_init(void)
{
	// Reset any pre-existing configuration
	SysTick->CTLR = 0x0000;
 45e:	e000f7b7          	lui	a5,0xe000f
	
	// Set the compare register to trigger once per millisecond
	SysTick->CMP = SYSTICK_ONE_MILLISECOND - 1;
 462:	6731                	lui	a4,0xc
	SysTick->CTLR = 0x0000;
 464:	0007a023          	sw	zero,0(a5) # e000f000 <_eusrstack+0xc000e800>
	SysTick->CMP = SYSTICK_ONE_MILLISECOND - 1;
 468:	b7f70713          	addi	a4,a4,-1153 # bb7f <example.c.5e9830c8+0x97fb>
 46c:	cb98                	sw	a4,16(a5)

	// Reset the Count Register, and the global millis counter to 0
	SysTick->CNT = 0x00000000;
 46e:	0007a423          	sw	zero,8(a5)
	systick_millis = 0x00000000;
 472:	c0418713          	addi	a4,gp,-1020 # 20000000 <systick_millis>
 476:	00072023          	sw	zero,0(a4)
	
	// Set the SysTick Configuration
	// NOTE: By not setting SYSTICK_CTLR_STRE, we maintain compatibility with
	// busywait delay funtions used by ch32v003_fun.
	SysTick->CTLR |= SYSTICK_CTLR_STE   |  // Enable Counter
 47a:	4398                	lw	a4,0(a5)
	NVIC->IENR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
 47c:	6685                	lui	a3,0x1
 47e:	c0418413          	addi	s0,gp,-1020 # 20000000 <systick_millis>
 482:	00776713          	ori	a4,a4,7
 486:	c398                	sw	a4,0(a5)
 488:	e000e737          	lui	a4,0xe000e
 48c:	10d72023          	sw	a3,256(a4) # e000e100 <_eusrstack+0xc000d900>
    systick_init();			//! required for millis()

    funGpioInitAll();
 490:	400216b7          	lui	a3,0x40021
 494:	4e98                	lw	a4,24(a3)
 496:	03576713          	ori	a4,a4,53
 49a:	ce98                	sw	a4,24(a3)
	uint32_t targend = SysTick->CNT + n;
 49c:	4798                	lw	a4,8(a5)
 49e:	004947b7          	lui	a5,0x494
 4a2:	e0078793          	addi	a5,a5,-512 # 493e00 <example.c.5e9830c8+0x491a7c>
 4a6:	973e                	add	a4,a4,a5
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
 4a8:	e000f6b7          	lui	a3,0xe000f
 4ac:	469c                	lw	a5,8(a3)
 4ae:	8f99                	sub	a5,a5,a4
 4b0:	fe07cee3          	bltz	a5,4ac <main+0x58>
		.pin = PD2,
        .TIM = TIM1,
		.CCER = TIM_CC1E
	};

	TIM_PWM_t pwm_CH1c = {
 4b4:	00040737          	lui	a4,0x40
 4b8:	03070713          	addi	a4,a4,48 # 40030 <example.c.5e9830c8+0x3dcac>
 4bc:	c2ba                	sw	a4,68(sp)
		.pin = PD0,
        .TIM = TIM1,
		.CCER = TIM_CC1NE
	};

	TIM_PWM_t pwm_CH2 = {
 4be:	00100737          	lui	a4,0x100
 4c2:	0705                	addi	a4,a4,1
 4c4:	da3a                	sw	a4,52(sp)
		.pin = PA1,
        .TIM = TIM1,
		.CCER = TIM_CC2E
	};
	
	TIM_PWM_t pwm_CH2c = {
 4c6:	00400737          	lui	a4,0x400
 4ca:	0709                	addi	a4,a4,2
 4cc:	d23a                	sw	a4,36(sp)
		.pin = PA2,
        .TIM = TIM1,
		.CCER = TIM_CC2NE
	};

	TIM_PWM_t pwm_CH3 = {
 4ce:	01000737          	lui	a4,0x1000
 4d2:	02370713          	addi	a4,a4,35 # 1000023 <example.c.5e9830c8+0xffdc9f>
 4d6:	ca3a                	sw	a4,20(sp)
    TIM_PWM_t pwm_CH1 = {
 4d8:	67c1                	lui	a5,0x10
        .TIM = TIM1,
		.CCER = TIM_CC3E
	};


	TIM_PWM_t pwm_CH4 = {
 4da:	10000737          	lui	a4,0x10000
    TIM_PWM_t pwm_CH1 = {
 4de:	03278793          	addi	a5,a5,50 # 10032 <example.c.5e9830c8+0xdcae>
	TIM_PWM_t pwm_CH4 = {
 4e2:	02470713          	addi	a4,a4,36 # 10000024 <example.c.5e9830c8+0xfffdca0>
    TIM_PWM_t pwm_CH1 = {
 4e6:	cabe                	sw	a5,84(sp)
	TIM_PWM_t pwm_CH4 = {
 4e8:	c23a                	sw	a4,4(sp)
    TIM_PWM_t pwm_CH1 = {
 4ea:	ce82                	sw	zero,92(sp)
 4ec:	d082                	sw	zero,96(sp)
	TIM_PWM_t pwm_CH1c = {
 4ee:	c682                	sw	zero,76(sp)
 4f0:	c882                	sw	zero,80(sp)
	TIM_PWM_t pwm_CH2 = {
 4f2:	de02                	sw	zero,60(sp)
 4f4:	c082                	sw	zero,64(sp)
	TIM_PWM_t pwm_CH2c = {
 4f6:	d602                	sw	zero,44(sp)
 4f8:	d802                	sw	zero,48(sp)
	TIM_PWM_t pwm_CH3 = {
 4fa:	ce02                	sw	zero,28(sp)
 4fc:	d002                	sw	zero,32(sp)
	TIM_PWM_t pwm_CH4 = {
 4fe:	c602                	sw	zero,12(sp)
 500:	c802                	sw	zero,16(sp)
	AFIO->PCFR1 |= AFIO_PCFR1_TIM1_REMAP_NOREMAP;
 502:	40010737          	lui	a4,0x40010
    TIM_PWM_t pwm_CH1 = {
 506:	400136b7          	lui	a3,0x40013
 50a:	4350                	lw	a2,4(a4)
 50c:	c0068793          	addi	a5,a3,-1024 # 40012c00 <_eusrstack+0x20012400>
 510:	ccbe                	sw	a5,88(sp)
	TIM_PWM_t pwm_CH1c = {
 512:	c4be                	sw	a5,72(sp)
	TIM_PWM_t pwm_CH2 = {
 514:	dc3e                	sw	a5,56(sp)
	TIM_PWM_t pwm_CH2c = {
 516:	d43e                	sw	a5,40(sp)
	TIM_PWM_t pwm_CH3 = {
 518:	cc3e                	sw	a5,24(sp)
	TIM_PWM_t pwm_CH4 = {
 51a:	c43e                	sw	a5,8(sp)
 51c:	c350                	sw	a2,4(a4)
		RCC->APB2PCENR |= RCC_APB2Periph_TIM1;
 51e:	40021737          	lui	a4,0x40021
 522:	4f0c                	lw	a1,24(a4)
 524:	6605                	lui	a2,0x1
 526:	80060613          	addi	a2,a2,-2048 # 800 <_data_lma+0x1f8>
 52a:	8dd1                	or	a1,a1,a2
 52c:	cf0c                	sw	a1,24(a4)
		RCC->APB2PRSTR |= RCC_APB2Periph_TIM1;
 52e:	474c                	lw	a1,12(a4)
        .TIM = TIM1,
		.CCER = TIM_CC4E
	};

	fun_timPWM_init(&pwm_CH1);
	fun_timPWM_reload(&pwm_CH1);
 530:	08c8                	addi	a0,sp,84
 532:	8e4d                	or	a2,a2,a1
 534:	c750                	sw	a2,12(a4)
		RCC->APB2PRSTR &= ~RCC_APB2Periph_TIM1;
 536:	4750                	lw	a2,12(a4)
 538:	75fd                	lui	a1,0xfffff
 53a:	7ff58593          	addi	a1,a1,2047 # fffff7ff <_eusrstack+0xdfffefff>
 53e:	8e6d                	and	a2,a2,a1
 540:	c750                	sw	a2,12(a4)
		timer->BDTR |= TIM_MOE;			// Enable TIM1 outputs
 542:	c446d703          	lhu	a4,-956(a3)
 546:	6621                	lui	a2,0x8
 548:	0742                	slli	a4,a4,0x10
 54a:	8341                	srli	a4,a4,0x10
 54c:	8f51                	or	a4,a4,a2
 54e:	c4e69223          	sh	a4,-956(a3)
	timer->PSC = 0x0000;			// Prescaler 
 552:	c2069423          	sh	zero,-984(a3)
	timer->ATRLR = 255;				// Auto Reload - sets period
 556:	0ff00713          	li	a4,255
 55a:	c2e69623          	sh	a4,-980(a3)
	timer->SWEVGR |= TIM_UG;		// Reload immediately
 55e:	c146d703          	lhu	a4,-1004(a3)
 562:	0742                	slli	a4,a4,0x10
 564:	8341                	srli	a4,a4,0x10
 566:	00176713          	ori	a4,a4,1
 56a:	c0e69a23          	sh	a4,-1004(a3)
	timer->CTLR1 |= TIM_CEN;		// Enable timer
 56e:	c006d783          	lhu	a5,-1024(a3)
 572:	07c2                	slli	a5,a5,0x10
 574:	83c1                	srli	a5,a5,0x10
 576:	0017e793          	ori	a5,a5,1
 57a:	c0f69023          	sh	a5,-1024(a3)
 57e:	3ead                	jal	f8 <fun_timPWM_reload>
	fun_timPWM_reload(&pwm_CH1c);
 580:	00c8                	addi	a0,sp,68
 582:	3e9d                	jal	f8 <fun_timPWM_reload>
	fun_timPWM_reload(&pwm_CH2);
 584:	1848                	addi	a0,sp,52
 586:	3e8d                	jal	f8 <fun_timPWM_reload>
	fun_timPWM_reload(&pwm_CH2c);
 588:	1048                	addi	a0,sp,36
 58a:	36bd                	jal	f8 <fun_timPWM_reload>
	fun_timPWM_reload(&pwm_CH3);
 58c:	0848                	addi	a0,sp,20
 58e:	36ad                	jal	f8 <fun_timPWM_reload>
	fun_timPWM_reload(&pwm_CH4);
 590:	0048                	addi	a0,sp,4
 592:	369d                	jal	f8 <fun_timPWM_reload>

    uint32_t sec_time = 0;
 594:	4781                	li	a5,0

    while(1) {
        uint32_t now = millis();
 596:	4004                	lw	s1,0(s0)

		fun_timPWM_task(now, &pwm_CH1);
 598:	08cc                	addi	a1,sp,84
 59a:	c03e                	sw	a5,0(sp)
 59c:	8526                	mv	a0,s1
 59e:	3975                	jal	25a <fun_timPWM_task>
		fun_timPWM_task(now, &pwm_CH1c);
 5a0:	00cc                	addi	a1,sp,68
 5a2:	8526                	mv	a0,s1
 5a4:	395d                	jal	25a <fun_timPWM_task>
		fun_timPWM_task(now, &pwm_CH2);
 5a6:	184c                	addi	a1,sp,52
 5a8:	8526                	mv	a0,s1
 5aa:	3945                	jal	25a <fun_timPWM_task>
		fun_timPWM_task(now, &pwm_CH2c);
 5ac:	104c                	addi	a1,sp,36
 5ae:	8526                	mv	a0,s1
 5b0:	316d                	jal	25a <fun_timPWM_task>
		fun_timPWM_task(now, &pwm_CH3);
 5b2:	084c                	addi	a1,sp,20
 5b4:	8526                	mv	a0,s1
 5b6:	3155                	jal	25a <fun_timPWM_task>
		fun_timPWM_task(now, &pwm_CH4);
 5b8:	004c                	addi	a1,sp,4
 5ba:	8526                	mv	a0,s1
 5bc:	3979                	jal	25a <fun_timPWM_task>

        if (now - sec_time > 1000) {
 5be:	4782                	lw	a5,0(sp)
 5c0:	3e800713          	li	a4,1000
 5c4:	40f486b3          	sub	a3,s1,a5
 5c8:	fcd777e3          	bgeu	a4,a3,596 <main+0x142>
			sec_time = now;
            printf(".");
 5cc:	02e00513          	li	a0,46
 5d0:	33c1                	jal	390 <putchar>
        uint32_t now = millis();
 5d2:	87a6                	mv	a5,s1
 5d4:	b7c9                	j	596 <main+0x142>

000005d6 <SysTick_Handler>:
* Increments Compare Register and systick_millis when triggered (every 1ms)
* NOTE: the `__attribute__((interrupt))` attribute is very important
*/
void SysTick_Handler(void) __attribute__((interrupt));
void SysTick_Handler(void)
{
 5d6:	1151                	addi	sp,sp,-12
 5d8:	c03e                	sw	a5,0(sp)
	// Increment the Compare Register for the next trigger
	// If more than this number of ticks elapse before the trigger is reset,
	// you may miss your next interrupt trigger
	// (Make sure the IQR is lightweight and CMP value is reasonable)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 5da:	e000f7b7          	lui	a5,0xe000f
{
 5de:	c23a                	sw	a4,4(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 5e0:	4b98                	lw	a4,16(a5)
{
 5e2:	c436                	sw	a3,8(sp)
	SysTick->CMP += SYSTICK_ONE_MILLISECOND;
 5e4:	66b1                	lui	a3,0xc
 5e6:	b8068693          	addi	a3,a3,-1152 # bb80 <example.c.5e9830c8+0x97fc>
 5ea:	9736                	add	a4,a4,a3
 5ec:	cb98                	sw	a4,16(a5)

	// Clear the trigger state for the next IRQ
	SysTick->SR = 0x00000000;
 5ee:	0007a223          	sw	zero,4(a5) # e000f004 <_eusrstack+0xc000e804>

	// Increment the milliseconds count
	systick_millis++;
 5f2:	c0418793          	addi	a5,gp,-1020 # 20000000 <systick_millis>
 5f6:	4398                	lw	a4,0(a5)
}
 5f8:	46a2                	lw	a3,8(sp)
	systick_millis++;
 5fa:	0705                	addi	a4,a4,1
 5fc:	c398                	sw	a4,0(a5)
}
 5fe:	4712                	lw	a4,4(sp)
 600:	4782                	lw	a5,0(sp)
 602:	0131                	addi	sp,sp,12
 604:	30200073          	mret
